/*
 * Copyright (C) 2016 Lefteris Paraskevas
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.left8.evs.evs.peakfinding.event;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import com.left8.evs.utilities.dsretriever.Tweet;
import com.left8.evs.edmodule.peakfinding.Window;
import com.left8.evs.edmodule.utils.Stemmers;
import com.left8.evs.preprocessingmodule.language.LangUtils;
import com.left8.evs.preprocessingmodule.nlp.Tokenizer;
import com.left8.evs.preprocessingmodule.nlp.stemming.StemUtils;
import com.left8.evs.evs.data.PeakFindingSentimentCorpus;
import com.left8.evs.utilities.Utilities;

/**
 *
 * @author  Lefteris Paraskevas
 * @version 2016.04.30_1829
 */
public class SentimentPeakFindingEvent {
    
    private final int id;
    private final Window<Integer, Integer> window;
    private final List<Tweet> tweetsOfEvent;
    private final List<String> commonTerms = new ArrayList<>();
    private HashSet<String> allTerms;
    private final PeakFindingSentimentCorpus corpus;
    private StemUtils stemsHandler;
    private int mainSentiment;
    private double positiveSentimentPerc;
    private double negativeSentimentPerc;
    private double neutralSentimentPerc;
    private double irrelevantSentimentPerc;
    private int uniqueUsers;
    
    /**
     * Public constructor. It creates an event.
     * @param id A String with the id of the event.
     * @param window A Window object with the window of the event.
     * @param tweetsOfEvent A List of String containing the corresponding tweetsOfEvent of the
     * event.
     * @param corpus A PeakFindingCorpus object.
     * @param sentimentSource The source of sentiment (internal or external).
     */
    public SentimentPeakFindingEvent(int id, Window<Integer, Integer> window, List<Tweet> tweetsOfEvent, 
            PeakFindingSentimentCorpus corpus, int sentimentSource) {
        this.id = id;
        this.window = window;
        this.tweetsOfEvent = new ArrayList<>(tweetsOfEvent);
        this.corpus = corpus;
        this.stemsHandler =  new StemUtils();
        generateCommonTerms();
        calculateSentimentStatistics(sentimentSource);
        calculateUniqueUsersOfEvent();
    }
    
    /**
     * Get the name of the event.
     * @return A String with event's name.
     */
    public final int getID() { return id; }
    
    /**
     * Get the window of the event.
     * @return Returns a Window object with the event's window.
     */
    public final Window<Integer, Integer> getWindow() { return window; }
    
    /**
     * Calculates the main sentiment of an event. <br>
     * More formally, it counts separately the sentiment of every tweet belonging
     * to a certain event and updates the field 'mainSentiment' with the appropriate
     * value.
     * @param sentimentSource The source of the sentiment with which the
     * calculations will take place. 0 indicates sentiments generated by Stanford
     * Sentiment Treebank, while 1 sentiments generated by Weka.
     */
    private void calculateSentimentStatistics(int sentimentSource) {
        int positiveCounter = 0;
        int negativeCounter = 0;
        int neutralCounter = 0;
        int irrelevantCounter = 0;
        int returnedSentiment;
        
        for(Tweet tweet : tweetsOfEvent) {
            if(sentimentSource == 0) { //Stanford
                returnedSentiment = tweet.getStanfordSentiment();
                if(returnedSentiment < 2) {
                    negativeCounter++;
                } else if(returnedSentiment > 2) {
                    positiveCounter++;
                } else { //2
                    neutralCounter++;
                }
            } else { //Weka
                if(sentimentSource == 1) {
                    returnedSentiment = tweet.getNaiveBayesSentiment();
                } else {
                    returnedSentiment = tweet.getBayesianNetSentiment();
                }
                if(returnedSentiment == 0) {
                    negativeCounter++;
                } else if(returnedSentiment == 1) {
                    neutralCounter++;
                } else if(returnedSentiment == 2) {
                    positiveCounter++;
                } else { //-2
                    irrelevantCounter++;
                }
            }   
        }
        int max = Math.max(positiveCounter, 
                Math.max(negativeCounter, 
                    Math.max(neutralCounter, irrelevantCounter)
                )
            );
        if(max == positiveCounter) {
            mainSentiment = 0;
        } else if(max == negativeCounter) {
            mainSentiment = 2;
        } else if(max == neutralCounter) {
            mainSentiment = 1;
        } else { //Irrelevant
            mainSentiment = -2;
        }
        positiveSentimentPerc = (double) positiveCounter / (double) tweetsOfEvent.size();
        negativeSentimentPerc = (double) negativeCounter / (double) tweetsOfEvent.size();
        neutralSentimentPerc = (double) neutralCounter / (double) tweetsOfEvent.size();
        irrelevantSentimentPerc = (double) irrelevantCounter / (double) tweetsOfEvent.size();
    }
    
    
    /**
     * Get the tweetsOfEvent of the event.
     * @return A List of String with the event's tweetsOfEvent.
     */
    public final List<Tweet> getTweetsOfEvent() { return tweetsOfEvent; }
    
    /**
     * Generates a List with the most common terms of the tweetsOfEvent that belong
     * to the specific event. <br>
     * More formally, it parses every single tweet of the event, tokenizes it
     * and stores the terms in a HashMap with their respective occurencies as
     * values.
     */
    private void generateCommonTerms() {
        HashMap<String, Integer> unsortedTokens = new HashMap<>();
        
        tweetsOfEvent.stream().forEach((tweet) -> {
            String text = tweet.getText();
            Tokenizer tokens = new Tokenizer(corpus.getPeakFindingCorpus().getConfigHandler(), text, 
                    corpus.getPeakFindingCorpus().getStopWordsHandlers().getSWHandlerAccordingToLanguage
                            (LangUtils.getLangISOFromString(tweet.getLanguage())));
            stemsHandler.getStemsAsList(tokens.getCleanTokensAndHashtags(),
                    Stemmers.getStemmer(LangUtils.getLangISOFromString(
                            tweet.getLanguage())))
                            .stream().forEach((token) -> {
                                if(unsortedTokens.containsKey(token)) {
                                    unsortedTokens.put(token, unsortedTokens.get(token) + 1); //Count it
                                } else {
                                    unsortedTokens.put(token, 1);
                                }
                            });
        });
        allTerms = new HashSet<>(unsortedTokens.keySet());
        sortMapByValue(unsortedTokens, stemsHandler);
    }
    
    /**
     * Calculates the unique users of the event.
     */
    private void calculateUniqueUsersOfEvent() {
        Set<Long> users = new HashSet<>();
        for(Tweet tweet : tweetsOfEvent) {
            users.add(tweet.getUserId());
        }
        uniqueUsers = users.size();
    }
    
    /**
     * Returns the five most common terms of the tweetsOfEvent that belong to this event.
     * @return A List of Strings with the most common terms.
     * @see generateCommonTerms generateCommonTerms() method.
     */
    public final List<String> getCommonTerms() {
        if(!commonTerms.isEmpty()) {
            return commonTerms;
        } else {
            Utilities.printMessageln("No common terms have been calculated yet!");
            Utilities.printMessageln("Run " + SentimentPeakFindingEvent.class + "." + "generateCommonTerms() method first.");
            return null;
        }
    }
    
    /**
     * Returns all the terms of the event.
     * @return A HashSet containing all event's terms.
     */
    public final HashSet<String> getAllTerms() { return allTerms; } 
    
    /**
     * Returns all the tweet IDs of the event.
     * @return A List containing all the tweet ID's of the event.
     */
    public final List<String> getTweetIDs() {
        List<String> ids = new ArrayList<>();
        for(Tweet tweet : tweetsOfEvent) {
            ids.add(String.valueOf(tweet.getID()));
        }
        return ids;
    }
    /**
     * Returns the five most common terms as a single String.
     * @return A String containing the five most common terms.
     * @see #getCommonTerms() getCommonTerms() method.
     */
    public final String getCommonTermsAsString() {
        if(commonTerms.isEmpty()) {
            Utilities.printMessageln("No common terms have been calculated yet!");
            Utilities.printMessageln("Run " + SentimentPeakFindingEvent.class + "." + "generateCommonTerms() method first.");
            return null;
        }
        String commonTermsString = "";
        for(String term : commonTerms) {
            commonTermsString = commonTermsString + term + " ";
        }
        return commonTermsString;
    }
    
    /**
     * Auxiliary method to sort a Map by value.
     * @param unsortedMap The Map to be sorted.
     * @param stemHandler A StemUtils object.
     */
    public final void sortMapByValue(HashMap<String, Integer> unsortedMap, StemUtils stemHandler) {
        //Initialize variables
        Entry<String,Integer> entry;
        String currentKey;
        int currentValue;
        
        //Get the 5 greatest tokens by value
        //If the HashMap has less than 5 elements, just sort them
        int size = (unsortedMap.keySet().size() < 5 ? unsortedMap.size() : 5);
        for(int i = 0; i < size; i++) {
            entry = unsortedMap.entrySet().iterator().next();
            currentKey = entry.getKey();
            currentValue = entry.getValue();
            for(String key : unsortedMap.keySet()) {
                if(unsortedMap.get(key) > currentValue) {
                    currentValue = unsortedMap.get(key);
                    currentKey = key;
                }
            }
            commonTerms.add(stemHandler.getOriginalWord(currentKey));
            unsortedMap.remove(currentKey);
        }
    }
    
    /**
     * Prints a specific event along with its tweetsOfEvent.
     */
    public final void printEvent() {
        Utilities.printMessageln("Event '" + getID() + "' contains the following common terms:");
        Utilities.printMessageln(getCommonTermsAsString());
    }
    
    /**
     * Get event's StemsHandler object.
     * @return A StemsHandler object.
     */
    public final StemUtils getStemsHandler() { return stemsHandler; }
    
    /**
     * Returns the point from which the event starts.
     * @return A date representing the event's window lower bound.
     */
    public final int getWindowLowerBound() { return window.getStart(); }
    
    /**
     * Returns the point by which the event ends.
     * @return A date representing the event's window upper bound.
     */
    public final int getWindowUpperBound() { return window.getEnd(); }
    
    /**
     * Returns the main sentiment of the event, which was already calculated in
     * the object's constructor.
     * @return An integer representing the event's main sentiment. 0 indicates
     * a positive sentiment, 1 a neutral one, 2 a negative one while -1 represents
     * an irrelevant sentiment.
     */
    public final int getMainSentimentOfEvent() { return mainSentiment; }
    
    /**
     * Returns the description of the main sentiment of the event.
     * @return The description of the main sentiment of the event.
     */
    public final String getMainSentimentOfEventDescription() {
        if(mainSentiment == 0) {
            return "Positive";
        } else if(mainSentiment == 1) {
            return "Neutral";
        } else if(mainSentiment == 2) {
            return "Negative";
        } else {
            return "Irrelevant";
        }
    }
    
    /**
     * Returns the percentage of tweets annotated as positive against the total
     * number of them.
     * @return A double representing the percentage of positive tweets.
     */
    public final double getPositiveSentimentPercentage() { return positiveSentimentPerc; }
    
    /**
     * Returns the percentage of tweets annotated as negative against the total
     * number of them.
     * @return A double representing the percentage of negative tweets.
     */
    public final double getNegativeSentimentPercentage() { return negativeSentimentPerc; }
    
    /**
     * Returns the percentage of tweets annotated as neutral against the total
     * number of them.
     * @return A double representing the percentage of neutral tweets.
     */
    public final double getNeutralSentimentPercentage() { return neutralSentimentPerc; }
    
    /**
     * Returns the percentage of tweets annotated as irrelevant against the total
     * number of them.
     * @return A double representing the percentage of irrelevant tweets.
     */
    public final double getIrrelevantSentimentPercentage() { return irrelevantSentimentPerc; }
    
    public final void printEventStatistics() {
        
        Utilities.printMessageln("Event " + id);
        Utilities.printMessageln("-------------");
        Utilities.printMessageln("Total tweets contained: " + tweetsOfEvent.size());
        Utilities.printMessageln("Total terms contained: " + allTerms.size());
        Utilities.printMessageln("Most common terms of event: " + getCommonTermsAsString());
        Utilities.printMessageln("Number of unique users in this event: " + uniqueUsers);
        Utilities.printMessageln("---Sentiment statistics---");
        Utilities.printMessageln("Main sentiment of event: " + getMainSentimentOfEventDescription());
        Utilities.printMessageln("Positive sentiment percentage: " + positiveSentimentPerc);
        Utilities.printMessageln("Negative sentiment percentage: " + negativeSentimentPerc);
        Utilities.printMessageln("Neutral sentiment percentage: " + neutralSentimentPerc);
        Utilities.printMessageln("Irrelevant sentiment percentage: " + irrelevantSentimentPerc);
        Utilities.printMessageln("The event is more " + 
                (positiveSentimentPerc > negativeSentimentPerc ? "positively oriented.\n" 
                        : "negatively oriented.\n"));
    }
}
